<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Sight-Singing Practice</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
  <style>
    body {
      background-color: #343a40;
      color: #fff;
      font-family: sans-serif;
      margin: 0;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
      touch-action: manipulation;
    }
    #keyboard {
      white-space: nowrap;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 10px;
    }
    .key {
      display: inline-block;
      position: relative;
      box-sizing: border-box;
      user-select: none;
      border: 1px solid #666;
      margin: 0;
      overflow: hidden;
    }
    .white-key { width: 60px; height: 225px; background: #fff; vertical-align: bottom; z-index: 1; }
    .black-key { width: 38px; height: 150px; background: #000; color: #fff; vertical-align: top; z-index: 2; margin: 0 -18px; }
    .sequence-label {
      position: absolute;
      bottom: 8px;
      left: 0;
      right: 0;
      text-align: center;
      font-weight: bold;
      font-size: 1.2em;
      color: #ff8484;
    }
    @media (max-width: 576px) {
      .white-key { width: 40px; height: 170px; }
      .black-key { width: 25px; height: 110px; margin: 0 -12px; }
      h1 { font-size: 1.5rem; }
      .sequence-label { bottom: 4px; font-size: 1em; }
      .control-buttons .btn { display: block; width: 100%; margin-bottom: 0.5rem; }
      .control-buttons .btn:last-child { margin-bottom: 0; }
    }
  </style>
</head>
<body class="bg-dark text-light">
<div class="container py-4">
  <h1 class="text-center mb-4">Sight-Singing Practice</h1>

  <div class="row g-3 align-items-end mb-4">
    <div class="col-md-4">
      <label for="lowestNoteSelect" class="form-label">Lowest Note</label>
      <select id="lowestNoteSelect" class="form-select form-select-sm"></select>
    </div>
    <div class="col-md-4">
      <label for="highestNoteSelect" class="form-label">Highest Note</label>
      <select id="highestNoteSelect" class="form-select form-select-sm"></select>
    </div>
    <div class="col-md-4">
      <label for="numNotesInput" class="form-label"># of Notes</label>
      <input type="number" id="numNotesInput" class="form-control form-control-sm" value="3" min="1" max="50">
    </div>
  </div>

  <div class="mb-4 control-buttons">
    <button id="nextBtn" class="btn btn-primary me-2">Next</button>
    <button id="playBtn" class="btn btn-success me-2">Play</button>
    <button id="playFirstBtn" class="btn btn-success">Play First</button>
  </div>

  <div id="keyboard" class="mb-3"></div>
</div>

<script>
  const ALL_NOTES = [];
  const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  for (let midi = 36; midi <= 96; midi++) {
    const octave = Math.floor(midi / 12) - 1;
    const name = NOTE_NAMES[midi % 12] + octave;
    const freq = 440 * Math.pow(2, (midi - 69) / 12);
    ALL_NOTES.push({ name, freq });
  }

  let currentNotes = [];
  let keyElements  = [];
  let randomSequence = [];

  const playback = { ctx: null, gain: null, oscillators: [], stopTimeout: null, isFadingOut: false };
  const FADE_IN_TIME  = 0.3;
  const FADE_OUT_TIME = 0.7;

  const keyboardDiv       = document.getElementById("keyboard");
  const lowestNoteSelect  = document.getElementById("lowestNoteSelect");
  const highestNoteSelect = document.getElementById("highestNoteSelect");
  const numNotesInput     = document.getElementById("numNotesInput");
  const nextBtn           = document.getElementById("nextBtn");
  const playBtn           = document.getElementById("playBtn");
  const playFirstBtn      = document.getElementById("playFirstBtn");

  function populateNoteSelects() {
    ALL_NOTES.forEach((note, idx) => {
      const optLow = document.createElement("option");
      optLow.value = idx;
      optLow.textContent = note.name;
      const optHigh = optLow.cloneNode(true);
      lowestNoteSelect.appendChild(optLow);
      highestNoteSelect.appendChild(optHigh);
    });
    const defaultLowest  = ALL_NOTES.findIndex(n => n.name === "C3");
    const defaultHighest = ALL_NOTES.findIndex(n => n.name === "C5");
    if (defaultLowest !== -1)  lowestNoteSelect.value  = defaultLowest;
    if (defaultHighest !== -1) highestNoteSelect.value = defaultHighest;
  }

  function buildKeyboard() {
    keyboardDiv.innerHTML = "";
    keyElements = [];
    const lowestIndex  = parseInt(lowestNoteSelect.value, 10);
    const highestIndex = parseInt(highestNoteSelect.value, 10);
    if (isNaN(lowestIndex) || isNaN(highestIndex)) return;
    const start = Math.min(lowestIndex, highestIndex);
    const end   = Math.max(lowestIndex, highestIndex);
    currentNotes = ALL_NOTES.slice(start, end + 1);
    currentNotes.forEach(note => {
      const div = document.createElement("div");
      div.classList.add("key");
      if (note.name.includes("#")) div.classList.add("black-key");
      else div.classList.add("white-key");
      keyboardDiv.appendChild(div);
      keyElements.push(div);
    });
  }

  function clearLabels() {
    keyElements.forEach(key => {
      const lbl = key.querySelector(".sequence-label");
      if (lbl) key.removeChild(lbl);
    });
  }

  function generateSequence() {
    clearLabels();
    randomSequence = [];
    let howMany = parseInt(numNotesInput.value, 10) || 3;
    if (howMany > currentNotes.length) howMany = currentNotes.length;
    const indices = [...Array(currentNotes.length).keys()];
    for (let i = indices.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [indices[i], indices[j]] = [indices[j], indices[i]];
    }
    const selected = indices.slice(0, howMany);
    randomSequence = selected.map(idx => ({ index: idx, freq: currentNotes[idx].freq }));
    randomSequence.forEach((item, i) => {
      const lbl = document.createElement("span");
      lbl.className = "sequence-label";
      lbl.textContent = i + 1;
      keyElements[item.index].appendChild(lbl);
    });
  }

  function startSequencePlayback(state, freqs, noteDuration = 0.8, gap = 0.1) {
    if (!freqs || freqs.length === 0) return;

    if (state.ctx && state.isFadingOut) {
      if (state.stopTimeout) { clearTimeout(state.stopTimeout); state.stopTimeout = null; }
      state.isFadingOut = false;
      const now = state.ctx.currentTime;
      state.gain.gain.cancelScheduledValues(now);
      state.gain.gain.setValueAtTime(Math.max(state.gain.gain.value, 0.0001), now);
      state.gain.gain.exponentialRampToValueAtTime(1, now + FADE_IN_TIME);
      return;
    }

    stopSequencePlayback(state);

    state.isFadingOut = false;
    state.ctx = new (window.AudioContext || window.webkitAudioContext)();
    const now = state.ctx.currentTime;

    state.gain = state.ctx.createGain();
    state.gain.connect(state.ctx.destination);
    state.gain.gain.setValueAtTime(0.0001, now);
    state.gain.gain.exponentialRampToValueAtTime(1, now + FADE_IN_TIME);

    state.oscillators = [];
    const amps = [0.12, 0.05, 0.03];
    freqs.forEach((freq, idx) => {
      const startTime = now + idx * (noteDuration + gap);
      const stopTime = startTime + noteDuration;
      amps.forEach((amp, i) => {
        const g = state.ctx.createGain();
        g.gain.value = amp;
        g.connect(state.gain);
        const osc = state.ctx.createOscillator();
        osc.type = "sine";
        osc.frequency.value = freq * (i + 1);
        osc.connect(g);
        osc.start(startTime);
        osc.stop(stopTime);
        state.oscillators.push(osc);
      });
    });

    const totalTime = freqs.length * (noteDuration + gap);
    state.stopTimeout = setTimeout(() => stopSequencePlayback(state), totalTime * 1000);
  }

  function stopSequencePlayback(state) {
    if (!state.ctx) return;
    const now = state.ctx.currentTime;
    state.isFadingOut = true;
    state.gain.gain.cancelScheduledValues(now);
    state.gain.gain.setValueAtTime(state.gain.gain.value, now);
    state.gain.gain.exponentialRampToValueAtTime(0.0001, now + FADE_OUT_TIME);

    if (state.stopTimeout) clearTimeout(state.stopTimeout);

    const ctx = state.ctx;
    const oscs = state.oscillators;
    state.stopTimeout = setTimeout(() => {
      oscs.forEach(o => { try { o.stop(); } catch(e){} });
      try { ctx.close(); } catch(e){}
      if (state.ctx === ctx) {
        state.ctx = null;
        state.gain = null;
        state.oscillators = [];
      }
      state.stopTimeout = null;
      state.isFadingOut = false;
    }, (FADE_OUT_TIME + 0.05) * 1000);
  }

  function startFullSequence() {
    if (!randomSequence.length) return;
    const freqs = randomSequence.map(obj => obj.freq);
    startSequencePlayback(playback, freqs, 0.8, 0.1);
  }

  function startFirstOnly() {
    if (!randomSequence.length) return;
    startSequencePlayback(playback, [randomSequence[0].freq], 1.0, 0);
  }

  function refreshSequence() {
    buildKeyboard();
    generateSequence();
  }

  lowestNoteSelect.addEventListener("change", refreshSequence);
  highestNoteSelect.addEventListener("change", refreshSequence);
  numNotesInput.addEventListener("change", generateSequence);
  nextBtn.addEventListener("click", generateSequence);

  function setupPlaybackButton(btn, startFn) {
    btn.addEventListener("pointerdown", startFn);
    ["pointerup","pointerleave","pointercancel"].forEach(evt =>
      btn.addEventListener(evt, () => stopSequencePlayback(playback))
    );
  }

  setupPlaybackButton(playBtn, startFullSequence);
  setupPlaybackButton(playFirstBtn, startFirstOnly);

  populateNoteSelects();
  buildKeyboard();
  generateSequence();
</script>
</body>
</html>
